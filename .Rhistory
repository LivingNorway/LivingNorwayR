# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = ""
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
termList
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
termList
stop("hello", "joe")
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE) {
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions), error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
}) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
})
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
termList
}
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE) {
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions), error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
termList
}
retrieveDwCTermSpecifications()
library(xml2)
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions), error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
termList
}
retrieveDwCTermSpecifications()
xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h3[@id=\"31-index-by-term-name\"]")
xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h3[@id=\"31-index-by-term-name\"]/following-sibling::p")
# TODO: add in some error handling if a connection to the server can't be made
# ====== 2.1. Retrieve classes from the Darwin core standard ======
# Download the landuage terms defined by the Darwin Core standard
langNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h3[@id=\"31-index-by-term-name\"]/following-sibling::p")
which(xml_text(landNodes) == "Classes")
which(xml_text(langNodes) == "Classes")
langNodes[[classIndex]]
# Find the index that is the list of classes supported by Darwin Core
classIndex <- which(xml_text(langNodes) == "Classes")[1] + 1
langNodes[[classIndex]]
xml_find_all(langNodes[[classIndex]], ".//p/a")
xml_find_all(langNodes[[classIndex]], ".//a")
xml_text(xml_find_all(langNodes[[classIndex]], ".//a"))
langNodes
termFrame <- retrieveDwCTermSpecifications(includeExtensions)
termFrame <- retrieveDwCTermSpecifications(FALSE)
unique(termFrame$type)
termFrame[termFrame$type == "Class", ]
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE, includeDepracated = FALSE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions), error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
if(tryCatch(as.locgicla(includeDepracated), error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
# If the terms list is to exclude depracted terms then remove them from the output
termList <- termList[is.na(termList$isReplacedBy), ]
}
termList
}
retrieveDwCTermSpecifications(FALSE, TRUE)
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE, includeDepracated = FALSE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions), error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
if(tryCatch(as.logical(includeDepracated), error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
# If the terms list is to exclude depracted terms then remove them from the output
termList <- termList[is.na(termList$isReplacedBy), ]
}
termList
}
retrieveDwCTermSpecifications(FALSE, TRUE)
retrieveDwCTermSpecifications(FALSE, FALSE)
nrow(retrieveDwCTermSpecifications(FALSE, TRUE))
nrow(retrieveDwCTermSpecifications(FALSE, FALSE))
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE, includeDepracated = FALSE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 1.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- do.call(rbind, lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output list for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
outList[, colName] <- gsub("^\\|", "", paste(outList[, colName], attrVal, sep = "|"), perl = TRUE)
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
outList
}))
# ====== 1.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions)[1], error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
rownames(termList) <- paste(termList$namespaceName, termList$termName, sep = ":")
if(tryCatch(as.logical(includeDepracated)[1] == FALSE, error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
# If the terms list is to exclude depracted terms then remove them from the output
termList <- termList[is.na(termList$isReplacedBy), ]
}
termList
}
classFrame <- termFrame[termFrame$type == "Class", ]
classFrame
colnames(classFrame)
is.na(termList$isReplacedBy) & termList$miscInformation != "This term is deprecated and should no longer be used"
is.na(classFrame$isReplacedBy) & classFrame$miscInformation != "This term is deprecated and should no longer be used"
is.na(classFrame$isReplacedBy) & ifelse(is.na(classFrame$miscInformation), "", classFrame$miscInformation) != "This term is deprecated and should no longer be used"
classFrame <- termFrame[termFrame$type == "Class", ]
if(tryCatch(as.logical(includeDepracated)[1] == FALSE, error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
classFrame <- classFrame[is.na(classFrame$isReplacedBy) & ifelse(is.na(classFrame$miscInformation), "", classFrame$miscInformation) != "This term is deprecated and should no longer be used", ]
}
classFrame <- classFrame[is.na(classFrame$isReplacedBy) & ifelse(is.na(classFrame$miscInformation), "", classFrame$miscInformation) != "This term is deprecated and should no longer be used", ]
curClassInfo <- as.matrix(classFrame)[1, ]
curClassInfo
as.character(c())
matrix(as.character(c()), nrow = 0, ncol = 14, dimnames = list(NULL, colnames(termFrame)))
as.data.frame(matrix(as.character(c()), nrow = 0, ncol = 14, dimnames = list(NULL, colnames(termFrame))))
