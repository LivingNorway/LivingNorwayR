# Sanity check the term IRI
private$termIRI <- characterScalarTest("term IRI", termIRI)
# Sanity check the term version IRI
private$termVersionIRI <- characterScalarTest("term version IRI", termVersionIRI)
# Sanity check the date modified
private$dateModified <- characterScalarTest("date modified", dateModified)
# Sanity check the label
private$label <- characterScalarTest("label", label)
# Sanity check the is replaced by
private$isReplacedBy <- characterScalarTest("\"is replaced by\"", isReplacedBy)
# Sanity check the definition
private$definition <- characterScalarTest("definition", definition)
# Sanity check the notes
private$notes <- characterVectorTest("notes", notes)
# Sanity check the type
private$type <- characterScalarTest("type", type)
# Sanity check the examples
private$examples <- characterVectorTest("examples", examples)
# Sanity check the Living Norway term information
private$termInformationLN <- characterVectorTest("Living Norway term information", termInformationLN)
# Sanity check the executive dicisions
private$execCommitteeDecisions <- characterVectorTest("executive committee decisiosn", execCommitteeDecisions)
# Sanity check the miscellaneous information
private$miscInformation <- characterVectorTest("miscellaneous information", miscInformation)
# Sanity check the term definition source
private$termDef <- characterScalarTest("term definition source", termDef)
# Return the object invisibly
=======
# An integer containing the index of the ID column in the dataset
idColumnIndex = integer(),
# An integer vector containing the indeces associated with terms associated with the class (those terms are given in the names attribute of the vector)
termMapping = integer(),
# A list of terms associated with the DwC class
associatedTerms = list(),
# A data frame containing the data held in the DwC object
objectData = data.frame(),
# ---- 1.1.1. Define a function to import the class information ----
# This is a private function called by other functions (called usually during initialisation of the class)
setClassInfo = function(classTermInfo, associatedTerms) {
# Utility function to test if the object is DwCTerm object
isTermsObject <- function(inVal) {
any(class(inVal) == "DwCTerm")
}
# Sanity check the class definition term
if(!isTermsObject(classTermInfo)) {
stop("error encountered during the processing of the class term information: input is not a DwCTerm object")
}
private$classTermInfo <- classTermInfo
# Sanity check the associated terms
private$associatedTerms <- tryCatch(associatedTerms, error = function(err) {
stop("error encountered during the processing of the associated terms information: ", err)
})
# Ensure that the composite terms are all DwCTerm objects
if(!all(sapply(X = private$associatedTerms, FUN = isTermsObject))) {
stop("error encountered during the processing of the associated terms information: one or more associated terms in not a DwcTerm object")
}
# Initialise the term mapping vector based on the names of the associated terms
private$termMapping <- setNames(as.integer(rep(NA, length(private$associatedTerms))), sapply(X = private$associatedTerms, FUN = function(curElement) {
curElement$getQualifiedName()
}))
if(any(duplicated(names(private$termMapping)))) {
stop("error encountered during the processing of the associated terms informations: duplicated qualified names of terms")
}
# Initialise a generic name for the object
private$objectName <- private$classTermInfo$getTermName()
# Initialise the data objects
private$objectData <- data.frame()
private$idColumnIndex <- integer()
# Return the object invisibly
invisible(self)
},
# ---- 1.1.2. Define a function to import the data ----
# This is a private function called by other functions (called usually during initialisation of the class)
setDataInfo = function(objectData, mappingInfo, idColumnInfo) {
# Utility function to convert an input value giving a column title into an index
getColIndex <- function(inName, inColNames) {
tempName <- inName
if(!is.character(tempName) && !is.factor(tempName)) {
tempName <- tryCatch(as.vector(tempName), error = function(err) {
stop("error encountered during processing of column index: ", err)
})
} else {
tempName <- tryCatch(as.character(tempName), error = function(err) {
stop("error encountered during processing of column index: ", err)
})
}
if(length(tempName) <= 0) {
stop("error encountered during procesing of column index: entry has zero length")
} else if(length(tempName) > 2) {
warning("more than one column option provided: only the first will be used")
tempName <- tempName[1]
}
if(is.character(inName)) {
# If the input is a character vector then find the corresponding index
tempName <- tryCatch(which(inName == as.character(inColNames)), error = function(err) {
stop("error encountered during processing of column index: ", err)
})
if(length(tempName) <= 0) {
stop("error encountered during processing of column index: name does not correspond to data column")
} else if(length(tempName) > 2) {
stop("error encountered during processing of column index: corresponding column name is duplicated")
}
}
# Convert the column index to an integer
tempName <- tryCatch(as.integer(tempName), error = function(err) {
stop("error encountered during processing of column index: ", err)
})
# Final quality control checks to ensure column indeces are valid
if(!is.null(inColNames)) {
stop("error encountered during processing of column index: data object does not have column names")
} else if(tempName <= 0 || tempName > length(inColNames)) {
stop("error encountered during processing of column index: index falls outside width of data object")
}
tempName
}
# Sanity test the input data
private$objectData <- tryCatch(as.data.frame(objectData), error = function(err) {
stop("error encountered during import of object data: ", err)
})
# Reinitialise the term mapping
private$termMapping <- setNames(as.integer(rep(NA, length(private$associatedTerms))), sapply(X = private$associatedTerms, FUN = function(curElement) {
curElement$getQualifiedName()
}))
# Sanity test the column mappings
termMapping <- tryCatch(
setNames(sapply(X = as.list(mappingInfo), FUN = getColIndex, inColNames = colnames(private$objectData)), names(mappingInfo)),
error = function(err) {
stop("error encountered during processing of mapping information: ", err)
})
if(is.null(names(termMapping))) {
stop("error encountered during processing of mapping information: mapping info has no names attribute")
}
private$termMapping[sapply(X = names(termMapping), FUN = function(curTerm, possTermNames) {
matchingIndeces <- unique(c(which(curTerm == possTermNames), which(curTerm == gsub("^.*\\:\\:", "", possTermNames, perl = TRUE))))
if(length(matchingIndeces) <= 0) {
stop("error encountered during processing of mapping information: specified term is not one recognised by the class")
} else if(length(matchingIndeces) > 1) {
stop("error encountered during processing of mapping information: ")
}
matchingIndeces[1]
}, possTermNames = names(private$termMapping))] <- termMapping
# Sanity test the ID column entry
private$idColumnIndex <- getColIndex(idColumnInfo, colnames(private$objectData))
# Return the object
invisible(self)
}
),
public = list(
# ====== 1.2. Function to set the name of the file in the Darwin core archive ======
#' @description
#' Set the name of the file that the data will print to when preparing the Darwin core archive
#' @param inFileName A character scalar giving the name to give the data file in a Darwin core archive
setTableName = function(inTableName) {
private$objectName <- tryCatch(as.character(inTableName), error = function(err) {
stop("error encountered whilst processing file name: ", err)
})
if(length(private$objectName) == 0) {
private$objectName <- private$classTermInfo$getTermName()
} else if(length(private$objectName) > 1) {
warning("entry for file name has more than one entry: only the first will be used")
private$objectName <- private$objectName[1]
}
if(is.na(private$objectName)) {
private$objectName <- private$classTermInfo$getTermName()
}
debug(DwCTerm$new)
DwCTerm$new("myTerm")
debug(characterScalarTest)
outVal
source('C:/CloudStorage/Work/LivingNorway/LivingNorwayR_GitHub/R/DwCTerm.R', echo=TRUE)
DwCTerm$new("newTerm")
DwCTerm$new("newTerm", "newWorkspace")
library(xml2)
as_xml_document(list(archive = list(core)))
as_xml_document(list(archive = list(core = "hello")))
xml_new_root()
?write.table
library(xml2)
?xml_new_document
xml_new_root(
.value = "arcive",
xmlns = "http://rs.tdwg.org/dwc/text/",
.version = "1.0",
.encoding = "UTF-8"
)
xmlOutput <- xml_new_root(
.value = "arcive",
xmlns = "http://rs.tdwg.org/dwc/text/",
.version = "1.0",
.encoding = "UTF-8"
)
xmlOutput
print(xmlOutput)
xmlOutput <- xml_new_root(
.value = "arcive",
xmlns = "http://rs.tdwg.org/dwc/text/",
xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance",
.version = "1.0",
.encoding = "UTF-8"
)
xmlOutput <- xml_new_root(
.value = "arcive",
xmlns = "http://rs.tdwg.org/dwc/text/",
"xmlns:xsi" = "http://www.w3.org/2001/XMLSchema-instance",
.version = "1.0",
.encoding = "UTF-8"
)
xmlOutput
xmlOutput <- xml_new_root(
.value = "arcive",
xmlns = "http://rs.tdwg.org/dwc/text/",
"xmlns:xsi" = "http://www.w3.org/2001/XMLSchema-instance",
"xmlns:xs" = "http://www.w3.org/2001/XMLSchema",
"xsi:schemaLocation" = "http://rs.tdwg.org/dwc/text/ http://rs.tdwg.org/dwc/text/tdwg_dwc_text.xsd",
.version = "1.0",
.encoding = "UTF-8"
)
cat(xmlOutput)
xmlOutput
xml_text(xmlOutput)
?xml_serialize
xml_serialize(xmlOutput, NULL)
write_xml(xmlOutput, "")
write_xml(xmlOutput)
write_xml(xmlOutput, NULL)
write_xml(xmlOutput, "C:/Temp/xmltest.xml")
?xml_add_child
library(xml2)
?xml_add_child
?write.table
getOption("encoding")
Sys.getlocale("LC_CTYPE")
Encoding("native.enc")
?localeToCharset
localeToCharset(Sys.getlocale("LC_CTYPE"))
?tryCatch
tryCatch(as.character(list(1:3, list(4:6, 7:9))))
tryCatch(stop("I am an error"), error = function(err, extra) { stop(err, "; ", extra) }, extra = "Hello")
tryCatch(stop("I am an error"), error = function(err, extra = "Hello") { stop(err, "; ", extra) }, extra = "Hello")
?xml_add_child
?xml_new_root
xmlOutput <- xml_new_root(
.value = "archive",
xmlns = "http://rs.tdwg.org/dwc/text/",
"xmlns:xsi" = "http://www.w3.org/2001/XMLSchema-instance",
"xmlns:xs" = "http://www.w3.org/2001/XMLSchema",
"xsi:schemaLocation" = "http://rs.tdwg.org/dwc/text/ http://rs.tdwg.org/dwc/text/tdwg_dwc_text.xsd",
.version = "1.0",
.encoding = "UTF-8"
)
xml_add_child(xmlOutput, .value = core, attrText = "Hello")
xml_add_child(xmlOutput, .value = "core", attrText = "Hello")
xmlOutput
xmlOutput <- xml_new_root(
.value = "archive",
xmlns = "http://rs.tdwg.org/dwc/text/",
"xmlns:xsi" = "http://www.w3.org/2001/XMLSchema-instance",
"xmlns:xs" = "http://www.w3.org/2001/XMLSchema",
"xsi:schemaLocation" = "http://rs.tdwg.org/dwc/text/ http://rs.tdwg.org/dwc/text/tdwg_dwc_text.xsd",
.version = "1.0",
.encoding = "UTF-8"
)
xmlCore <- xml_add_child(xmlOutput, .value = "core", attrText = "Hello")
xmlCore
xml_add_child(xmlCore, .value = "field", gText = "Go!")
xmlOutput
?xml_add_child
?write.table
?tempdir
paste(tempdir(), "tempDwCArchive", sep = "/")
file.path(tempdir(), "sep")
.Platform$file.sep
file.path(tempdir(), "tempDwCArchive")
time()
timestamp()
##------ Tue Nov 24 13:14:16 2020 ------##
?timestamp
?time
Sys.time()
as.POSIXct(Sys.time())
?as.POSIXct
as.POSIXlt(Sys.time())
Sys.time()
gsub("[\\-\\:]", "_", Sys.time(), perl = TRUE)
gsub("[\\-\\:\\s]", "_", Sys.time(), perl = TRUE)
paste("tempDwCArchive", gsub("[\\-\\:\\s]", "_", Sys.time(), perl = TRUE), sep = "_")
file.path(tempdir(), paste("tempDwCArchive", gsub("[\\-\\:\\s]", "_", Sys.time(), perl = TRUE), sep = "_"))
?dir.create
?zip
?dir.create
?unlink
?zip
?write.table
file.path(tempdir(), c("joe", "inge"))
retrieveDwCClassSpecifications <- function(includeExtensions = TRUE, includeDeprecated = FALSE) {
# TODO: add in some error handling if a connection to the server can't be made
# ====== 3.1. Retrieve terms from the Darwin core standard ======
termList <- retrieveDwCTermSpecifications(includeExtensions, includeDeprecated)
# ====== 3.2. Retrieve classes from the Darwin core standard ======
classList <- termList[sapply(X = termList, FUN = function(curOb) { curOb$getType() == "Class" })]
# Download the landuage terms defined by the Darwin Core standard
langNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//p[preceding-sibling::h3[@id=\"31-index-by-term-name\"] and following-sibling::h3[@id=\"32-index-by-label\"]]")
setNames(lapply(X = classList, FUN = function(curClassInfo, langNodes, termList) {
# Initialise an output list
outList <- list(
termInfo = curClassInfo,
compositeTerms = list()
)
# Lookup the HTML node containing the specification for the class
nodeIndex <- which(xml_text(langNodes) == outList$termInfo$getLabel())
if(length(nodeIndex) > 0) {
# Get the terms associated with the class
termLabels <- strsplit(xml_text(langNodes)[nodeIndex[1] + 1], "\\s*\\|\\s*", perl = TRUE)[[1]]
termLabels <- termLabels[termLabels %in% names(termList)]
outList$compositeTerms <- termList[termLabels]
}
outList
}, langNodes = langNodes, termList = termList), names(classList))
}
classInfo <- retrieveDwCClassSpecifications()
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE, includeDeprecated = FALSE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 2.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output data.frame for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
termDef = "https://dwc.tdwg.org/",
vocabularyURI = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
delimToUse <- "|||"
if(outList[, colName] == "") {
outList[, colName] <- attrVal
} else {
outList[, colName] <- paste(outList[, colName], attrVal, sep = delimToUse)
}
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
DwCTerm$new(termName = outList$termName, namespaceName = outList$namespaceName, termIRI = outList$termIRI, termVersionIRI = outList$termVersionIRI,
dateModified = outList$dateModified, label = outList$label, isReplacedBy = outList$isReplacedBy, definition = outList$definition, notes = strsplit(outList$notes, delimToUse, fixed = TRUE)[[1]],
type = outList$type, examples = strsplit(outList$examples, delimToUse, fixed = TRUE)[[1]], termInformationLN = strsplit(outList$termInformationLN, delimToUse, fixed = TRUE)[[1]],
execCommitteeDecisions = strsplit(outList$execCommitteeDecisions, delimToUse, fixed = TRUE)[[1]], miscInformation = strsplit(outList$miscInformation, delimToUse, fixed = TRUE)[[1]],
termDef = outList$termDef, vocabularyURI = outList$vocabularyURI)
})
# ====== 2.2. Retrieve concepts from TDWG ======
# Currently this isn't supported because we need to have access to the Biodiversity Information Standards database
# on biological concepts. There are around 13000 concepts listed there (some of which are supported by GBIF) and
# to support some of GBIF's registered extensions to Darwin Core we need an automated interface
if(tryCatch(as.logical(includeExtensions)[1], error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# TODO: put processing of extension terms here
warning("extension terms not currently supported")
}
# ====== 2.3. Process the outputs ======
# Use qualified names to index the list
names(termList) <- sapply(X = termList, FUN = function(curOb) {
curOb$getQualifiedName()
})
if(tryCatch(as.logical(includeDeprecated)[1] == FALSE, error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
# If the terms list is to exclude depracted terms then remove them from the output
termList <- termList[!sapply(X = termList, FUN = function(curOb) { curOb$isDeprecated() })]
# termList <- termList[is.na(termList$isReplacedBy) & ifelse(is.na(termList$miscInformation), "", termList$miscInformation) != "This term is deprecated and should no longer be used.", ]
}
termList
}
# ------ 3. FUNCTION TO RETRIEVE LIST OF DARWIN CORE CLASSES ------
#' Retrieve classes and their related term used by Darwin core
#'
#' @param includeExtensions A \code{logical} scalar that, if \code{TRUE}, instructs the fuction to also
#' include classes used in registered Darwin core extensions. If \code{FALSE}, only the classes specified by
#' the Darwin core standard is included
#' @param includeDeprecated A \code{logical} scalar that, if \code{TRUE}, instructs the function to also
#' include terms in the Dawin Core standard that are depracated
#'
#' @return A \code{list} containing one element per class. Each element is itself a \code{list} with the
#' following named elements:
#' \itemize{
#'   \item{termInfo}{A \code{DwCTerm} object containing the information of the class term}
#'   \item{compositeTerms}{A \code{list} of \code{DwCTerm} objects for each term that is associated with
#'   the class}
#' }
#'
#' @seealso \code{\link[retrieveDwCTermSpecifications]{retrieveDwCTermSpecifications}}
#' \code{\link[DwCTerm]{DwCTerm}}
#' @author Joseph D. Chipperfield, \email{joechip90@@googlemail.com}
#'
retrieveDwCClassSpecifications <- function(includeExtensions = TRUE, includeDeprecated = FALSE) {
# TODO: add in some error handling if a connection to the server can't be made
# ====== 3.1. Retrieve terms from the Darwin core standard ======
termList <- retrieveDwCTermSpecifications(includeExtensions, includeDeprecated)
# ====== 3.2. Retrieve classes from the Darwin core standard ======
classList <- termList[sapply(X = termList, FUN = function(curOb) { curOb$getType() == "Class" })]
# Download the landuage terms defined by the Darwin Core standard
langNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//p[preceding-sibling::h3[@id=\"31-index-by-term-name\"] and following-sibling::h3[@id=\"32-index-by-label\"]]")
setNames(lapply(X = classList, FUN = function(curClassInfo, langNodes, termList) {
# Initialise an output list
outList <- list(
termInfo = curClassInfo,
compositeTerms = list()
)
# Lookup the HTML node containing the specification for the class
nodeIndex <- which(xml_text(langNodes) == outList$termInfo$getLabel())
if(length(nodeIndex) > 0) {
# Get the terms associated with the class
termLabels <- strsplit(xml_text(langNodes)[nodeIndex[1] + 1], "\\s*\\|\\s*", perl = TRUE)[[1]]
termLabels <- termLabels[termLabels %in% names(termList)]
outList$compositeTerms <- termList[termLabels]
}
outList
}, langNodes = langNodes, termList = termList), names(classList))
}
=======
DwCGeneric
library(LivingNorwayR)
library(LivingNorwayR)

