#' @description
#' Create a new GBIFEvent object
#' @param objectData A \code{data.frame} containing the data to import into the object
#' @param idColumnInfo Either a \code{character} scalar containing the column name of
#' \code{objectData} or an \code{integer} scalar giving the index of the column of
#' \code{objectData} that corresponds to the ID variable.  Alternatively, this parameter
#' may be the qualified name of the Darwin core term for which the appropriately mapped column
#' will be used as the ID variable (the possible Darwin core term names can be found by running
#' \code{names(getGBIFEventMembers())})
#' @param nameAutoMap A \code{logical} scalar that if \code{TRUE} maps the columns of \code{objectData}
#' to their respective Darwin core terms based on the column names
#' @param defDateFormat A \code{character} scalar providing the default format for strings denoting dates in the
#' data table.  See the \url{https://dwc.tdwg.org/text/#1-introduction}{Darwin Core text guide} for expected values
#' for this string.
#' @param ... A named set of paramaeters corresponding to Darwin core terms associated with the GBIFEvent
#' class type.  Each is either a \code{character} scalar containing the column name of \code{objectData}
#' or an \code{integer} scalar giving the index of the column of \code{objectData} that corresponds to the
#' term. Mappable terms can be found using: \code{sapply(X = getGBIFEventMembers(), FUN = function(curTerm) { curTerm$getTermName() })}
#' @return A new \code{GBIFEvent} object
#' @seealso \code{\link[DwCTerm]{DwCTerm}} \code{\link[getGBIFEventMembers]{getGBIFEventMembers}}
initialize = function(objectData, idColumnInfo, nameAutoMap = FALSE, defDateFormat = "YYYY-MM-DD", ...) {
super$initialize(
getGBIFEventTerm(),
getGBIFEventMembers(),
objectData,
idColumnInfo,
nameAutoMap,
defDateFormat,
...
)
invisible(self)
}
)
)
# ------ 4. INITIALISATION FUNCTION ------
#' Initialize a new GBIF Event object
#' @param objectData A \code{data.frame} containing the data to import into the object
t#' @param idColumnInfo Either a \code{character} scalar containing the column name of
#' \code{objectData} or an \code{integer} scalar giving the index of the column of
#' \code{objectData} that corresponds to the ID variable.  Alternatively, this parameter
#' may be the qualified name of the Darwin core term for which the appropriately mapped column
#' will be used as the ID variable (the possible Darwin core term names can be found by running
#' \code{names(getGBIFEventMembers())})
#' @param nameAutoMap A \code{logical} scalar that if \code{TRUE} maps the columns of \code{objectData}
#' to their respective Darwin core terms based on the column names
#' @param defDateFormat A \code{character} scalar providing the default format for strings denoting dates in the
#' data table.  See the \url{https://dwc.tdwg.org/text/#1-introduction}{Darwin Core text guide} for expected values
#' for this string.
#' @param ... A named set of paramaeters corresponding to Darwin core terms associated with the GBIFEvent
#' class type.  Each is either a \code{character} scalar containing the column name of \code{objectData}
#' or an \code{integer} scalar giving the index of the column of \code{objectData} that corresponds to the
#' term. Mappable terms can be found using: \code{sapply(X = getGBIFEventMembers(), FUN = function(curTerm) { curTerm$getTermName() })}
#' @return A new \code{GBIFEvent} object
#' @seealso \code{\link[DwCTerm]{DwCTerm}} \code{\link[getGBIFEventMembers]{getGBIFEventMembers}}
initializeGBIFEvent <- function(objectData, idColumnInfo, nameAutoMap = FALSE, defDateFormat = "YYYY-MM-DD", ...) {
GBIFEvent$new(objectData = objectData, idColumnInfo = idColumnInfo, nameAutoMap = nameAutoMap, defDateFormat = defDateFormat, ...)
}
initializeGBIFEvent()
getGBIFEventTerm
getGBIFEventTerm()
getGBIFEventTerm("countryCode")
load("C:/Users/matthew.grainger/Documents/Projects_in_development/LivingNorwayR/R/sysdata.rda")
View(DwCClassList)
# ------ 2. UPDATE DARWIN CORE TERM LISTS AND CLASS ASSOCIATIONS ------
termList <- retrieveDwCTermSpecifications(TRUE, TRUE)
View(DwCClassList)
paste("DwC", classInformation$termName, " <- R6Class(\"DwC", classInformation$termName, "\", ", sep = ""),
")",
sep = "\n")
classText <- paste(
paste("DwC", classInformation$termName, " <- R6Class(\"DwC", classInformation$termName, "\", ", sep = ""),
")",
sep = "\n")
termList <- retrieveDwCTermSpecifications(TRUE, TRUE)
# ------ 1. EVENT TERM INFORMATION ------
#' Return the information of the term associated with the GBIF Event class
#' @return A \code{DwCTerm} object containing the term information
#' @seealso \code{\link[DwCTerm]{DwCTerm}}
getGBIFEventTerm <- function() {
outValue <- NULL
if("http://rs.tdwg.org/dwc/terms/Event" %in% names(GBIFCoreClassList)) {
outValue <- GBIFCoreClassList[["http://rs.tdwg.org/dwc/terms/Event"]]$termInfo
} else if("http://rs.tdwg.org/dwc/terms/Event" %in% names(GBIFExtClassList)) {
outValue <- GBIFExtClassList[["http://rs.tdwg.org/dwc/terms/Event"]]$termInfo
}
outValue
}
getGBIFEventTerm()
View(DwCClassList)
GBIFCoreClassList
GBIFCoreClassList=load("C:/Users/matthew.grainger/Documents/Projects_in_development/LivingNorwayR/R/sysdata.rda")
GBIFCoreClassList
load("C:/Users/matthew.grainger/Documents/Projects_in_development/LivingNorwayR/R/sysdata.rda")
DwCClassList
DwCClassList$`http://rs.tdwg.org/dwc/terms/Occurrence`
# ------ 1. OCCURRENCE TERM INFORMATION ------
#' Return the information of the term associated with the GBIF Occurrence class
#' @return A \code{DwCTerm} object containing the term information
#' @seealso \code{\link[DwCTerm]{DwCTerm}}
getGBIFOccurrenceTerm <- function() {
outValue <- NULL
if("http://rs.tdwg.org/dwc/terms/Occurrence" %in% names(GBIFCoreClassList)) {
outValue <- GBIFCoreClassList[["http://rs.tdwg.org/dwc/terms/Occurrence"]]$termInfo
} else if("http://rs.tdwg.org/dwc/terms/Occurrence" %in% names(GBIFExtClassList)) {
outValue <- GBIFExtClassList[["http://rs.tdwg.org/dwc/terms/Occurrence"]]$termInfo
}
outValue
}
getGBIFOccurrenceTerm()
# ------ 1. OCCURRENCE TERM INFORMATION ------
#' Return the information of the term associated with the GBIF Occurrence class
#' @return A \code{DwCTerm} object containing the term information
#' @seealso \code{\link[DwCTerm]{DwCTerm}}
getGBIFOccurrenceTerm <- function() {
outValue <- NULL
if("http://rs.tdwg.org/dwc/terms/Occurrence" %in% names(DwCClassList)) {
outValue <- GBIFCoreClassList[["http://rs.tdwg.org/dwc/terms/Occurrence"]]$termInfo
} else if("http://rs.tdwg.org/dwc/terms/Occurrence" %in% names(GBIFExtClassList)) {
outValue <- GBIFExtClassList[["http://rs.tdwg.org/dwc/terms/Occurrence"]]$termInfo
}
outValue
}
getGBIFOccurrenceTerm()
getGBIFOccurrenceTerm("Date")
DwCClassList
outValue <- GBIFCoreClassList[["http://rs.tdwg.org/dwc/terms/Occurrence"]]$compositeTerms
DwCClassList$`http://rs.tdwg.org/dwc/terms/Occurrence`$compositeTerms
DwCClassList$`http://rs.tdwg.org/dwc/terms/Occurrence`$termInfo
retrieveGBIFClassSpecifications("core", TRUE)
retrieveDwCClassSpecifications
retrieveDwCClassSpecifications()
#' @param includeDeprecated A \code{logical} scalar that, if \code{TRUE}, instructs the function to also
#' include terms in the Dawin Core standard that are deprecated
#'
#' @return A \code{list} of \code{DwCTerm} objects representing the terms defined by the Darwin core
#' standard
#'
#' @seealso \code{\link[retrieveDwCClassSpecifications]{retrieveDwCClassSpecifications}}
#' \code{\link[DwCTerm]{DwCTerm}}
#' @author Joseph D. Chipperfield, \email{joechip90@@googlemail.com}
#'
retrieveDwCTermSpecifications <- function(includeExtensions = TRUE, includeDeprecated = FALSE) {
# TODO: add in some error handling if a conection to the server can't be made
# ====== 2.1. Retrieve terms from Darwin core standard =====
# Download terms defined by the Darwin Core standard
termNodes <- xml_find_all(read_html("https://dwc.tdwg.org/list/"), "//h2[@id=\"4-vocabulary\"]/following-sibling::table")
termList <- lapply(X = termNodes, FUN = function(curNode) {
# Initialise an output data.frame for the term entry
outList <- data.frame(
# Retrieve the name of the term as defined (and its namespace)
termName = gsub("^.*\\:([\\w\\-]+)\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")),perl = TRUE),
namespaceName = switch(
gsub("^.*\\s([\\w\\-]+)\\:[\\w\\-]+\\s*$", "\\1", xml_text(xml_find_first(curNode, ".//thead")), perl = TRUE),
"dwc" = "http://rs.tdwg.org/dwc/terms/",
"dwciri" = "http://rs.tdwg.org/dwc/iri/",
"dc" = "http://purl.org/dc/elements/1.1/",
"dcterms" = "http://purl.org/dc/terms/",
""
),
termIRI = "",
termVersionIRI = "",
dateModified = "",
label = "",
isReplacedBy = "",
definition = "",
notes = "",
type = "",
examples = "",
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = "",
termDef = "https://dwc.tdwg.org/",
vocabularyURI = "",
stringsAsFactors = FALSE
)
# Look through the table of attributes for the term and populate the list
for(infoNode in xml_find_all(curNode, ".//tbody/tr")) {
colNodes <- xml_find_all(infoNode, ".//td")
attrName <- xml_text(colNodes[1])
attrVal <- xml_text(colNodes[2])
colName <- switch(attrName,
"Term IRI" = "termIRI",
"Term version IRI" = "termVersionIRI",
"Modified" = "dateModified",
"Label" = "label",
"Is replaced by" = "isReplacedBy",
"Definition" = "definition",
"Notes" = "notes",
"Type" = "type",
"Examples" = "examples",
"Executive Committee decision" = "execCommitteeDecisions",
"miscInformation")
delimToUse <- "|||"
if(outList[, colName] == "") {
outList[, colName] <- attrVal
} else {
outList[, colName] <- paste(outList[, colName], attrVal, sep = delimToUse)
}
}
outList[1, ] <- ifelse(outList[1, ] == "", NA, outList[1, ])
DwCTerm$new(termName = outList$termName, namespaceName = outList$namespaceName, termIRI = outList$termIRI, termVersionIRI = outList$termVersionIRI,
dateModified = outList$dateModified, label = outList$label, isReplacedBy = outList$isReplacedBy, definition = outList$definition, notes = strsplit(outList$notes, delimToUse, fixed = TRUE)[[1]],
type = outList$type, examples = strsplit(outList$examples, delimToUse, fixed = TRUE)[[1]], termInformationLN = strsplit(outList$termInformationLN, delimToUse, fixed = TRUE)[[1]],
execCommitteeDecisions = strsplit(outList$execCommitteeDecisions, delimToUse, fixed = TRUE)[[1]], miscInformation = strsplit(outList$miscInformation, delimToUse, fixed = TRUE)[[1]],
termDef = outList$termDef, vocabularyURI = outList$vocabularyURI)
})
# ====== 2.2. Retrieve GBIF extensions terms ======
# If requested, download terms defined in the GBIF registered extensions
if(tryCatch(as.logical(includeExtensions)[1], error = function(err) {
stop("error encountered during processing of extensions inclusion parameter: ", err)
})) {
# Function to read all the terms specified at a given URL
retrieveXMLSpecs <- function(specAddress) {
# Function to read the GBIF XML file
readGBIFXML <- function(specAddress) {
curDoc <- read_xml(specAddress)
# Class name
className <- switch(xml_attr(curDoc, "rowType"),
"http://data.ggbn.org/schemas/ggbn/terms/Cloning" = "Cloning",   # Cloning class has the 'Amplification' name.  Manually need to over-ride that here
xml_attr(curDoc, "name"))
# Convert each of the child nodes of the xml specification to terms objects
append(lapply(X = xml_children(curDoc), FUN = function(curNode, curDoc) {
DwCTerm$new(
termName = xml_attr(curNode, "name"),
namespaceName = xml_attr(curNode, "namespace"),
termIRI = xml_attr(curNode, "rowType"),
termVersionIRI = xml_attr(curNode, "rowType"),
dateModified = xml_attr(curDoc, "issued"),
label = xml_attr(curNode, "name"),
isReplacedBy = "",
definition = xml_attr(curNode, "description"),
notes = xml_attr(curNode, "description"),
type = xml_name(curNode),
examples = xml_attr(curNode, "examples"),
termInformationLN = "",
execCommitteeDecisions = "",
miscInformation = paste("GBIF sub-class designation: ", ifelse(is.na(xml_attr(curNode, "group")), "unknown", xml_attr(curNode, "group")), sep = ""),
vocabularyURI = xml_attr(curNode, "thesaurus")
)
}, curDoc = curDoc), list(
# Convert the countaining class to a a terms object
DwCTerm$new(
termName = className,
namespaceName = xml_attr(curDoc, "namespace"),
termIRI = xml_attr(curDoc, "rowType"),
termVersionIRI = xml_attr(curDoc, "rowType"),
dateModified = xml_attr(curDoc, "issued"),
label = className,
isReplacedBy = "",
definition = xml_attr(curDoc, "description"),
notes = xml_attr(curDoc, "description"),
type = "class",
examples = "",
termInformationLN = "",
miscInformation = paste("GBIF core/extension class"),
vocabularyURI = xml_attr(curDoc, "relation")
)
))
}
# Retrieve the link nodes for all the entries in the specification page
if(!grepl("/$", specAddress, perl = TRUE)) {
specAddress <- paste(specAddress, "/", sep = "")
}
aNodes <- xml_find_all(read_html(specAddress), "//td/a")
aLinks <- sapply(X = aNodes[2:length(aNodes)], FUN = xml_attr, attr = "href")
# Go through each of the links and process each entry
unlist(lapply(X = aLinks, FUN = function(curLink, curBaseAddress) {
outVals <- list()
if(grepl("\\.xml$", curLink, perl = TRUE)) {
# If the link is to a XML file then scrape the property information from it
outVals <- readGBIFXML(paste(curBaseAddress, curLink, sep = ""))
} else if(grepl("/$", curLink, perl = TRUE)) {
# If the link is to another folder then call the function recursively
outVals <- retrieveXMLSpecs(paste(curBaseAddress, curLink, sep = ""))
}
outVals
}, curBaseAddress = specAddress))
}
# Retrieve the term specifications for both the core and extension elements
GBIFSpecs <- append(
retrieveXMLSpecs("https://rs.gbif.org/core/"),
retrieveXMLSpecs("https://rs.gbif.org/extension/")
)
# Remove those entries in the GBIF specifications that are already in the Darwin Core specification and append those to in the
# Darwin core specification
termList <- append(termList, GBIFSpecs[sapply(X = GBIFSpecs, FUN = function(curSpec, termList) {
!any(curSpec$getQualifiedName() == sapply(X = termList, FUN = function(curTerm) { curTerm$getQualifiedName() }))
}, termList = termList)])
}
# ====== 2.3. Process the outputs ======
# Use qualified names to index the list
names(termList) <- sapply(X = termList, FUN = function(curOb) {
curOb$getQualifiedName()
})
if(tryCatch(as.logical(includeDeprecated)[1] == FALSE, error = function(err) {
stop("error encountered during processing of depracation inclusion parameter: ", err)
})) {
# If the terms list is to exclude depracted terms then remove them from the output
termList <- termList[!sapply(X = termList, FUN = function(curOb) { curOb$isDeprecated() })]
}
termList
}
retrieveDwCTermSpecifications()
retrieveDwCTermSpecifications
LivingNorwayData::Seapop
SeaPop=LivingNorwayData::Seapop
LivingNorwayR::get_NOR_geographic_extent(SeaPop, SeaPop$decimalLatitude, SeaPop$decimalLongitude, 4326)
library(LivingNorwayR)
LivingNorwayR::get_NOR_geographic_extent(SeaPop, SeaPop$decimalLatitude, SeaPop$decimalLongitude, 4326)
library(tidyverse)
LivingNorwayR::get_NOR_geographic_extent(SeaPop, SeaPop$decimalLatitude, SeaPop$decimalLongitude, 4326)
df.sf <- sf::st_as_sf(SeaPop, coords = c(decimalLatitude, decimalLongitude) )
df.sf <- sf::st_as_sf(SeaPop, coords = c(SeaPop$decimalLatitude, SeaPop$decimalLongitude) )
df.sf <- sf::st_as_sf(SeaPop, coords = c(SeaPop$decimalLongitude, SeaPop$decimalLatitude) )
my.sf.point <- sf::st_as_sf(x = SeaPop,
coords = c(SeaPop$decimalLongitude, SeaPop$decimalLatitude),
crs = "+proj=longlat +datum=WGS84")
my.sf.point <- sf::st_as_sf(x = SeaPop,
coords = c(as.numeric(SeaPop$decimalLongitude), as.numeric(SeaPop$decimalLatitude)),
crs = "+proj=longlat +datum=WGS84")
str(SeaPop)
SeaPop$decimalLatitude
df=SeaPop
X=SeaPop$decimalLatitude
Y=SeaPop$decimalLongitude
df.sf <- sf::st_as_sf(df, coords = c(X, Y) ) %>%
sf::st_set_crs(Code) %>%   #set coordinate system used
sf::st_transform(4326)     #transform coordinates to WGS84 coordinates
Code=32362
get_NOR_geographic_extent<-function(df,X,Y,Code){
df.sf <- sf::st_as_sf(df, coords = c(X, Y) ) %>%
sf::st_set_crs(Code) %>%   #set coordinate system used
sf::st_transform(4326)     #transform coordinates to WGS84 coordinates
leaflet::leaflet() %>%
leaflet::addTiles() %>%
leaflet::addMarkers(data=df.sf)
}
df.sf <- sf::st_as_sf(df, coords = c(X, Y) ) %>%
sf::st_set_crs(Code) %>%   #set coordinate system used
sf::st_transform(4326)     #transform coordinates to WGS84 coordinates
rlang::last_error()
df.sf <- sf::st_as_sf(df, coords = c(X, Y) )
sf::st_as_sf(df, coords = c(X, Y) )
install.packages("sf")
sf::st_as_sf(df, coords = c(X, Y) )
rs_data = rgdal::make_EPSG()
View(crs_data)
crs_data = rgdal::make_EPSG()
View(crs_data)
Code=5939
df.sf <- sf::st_as_sf(df, coords = c(X, Y) ) %>%
sf::st_set_crs(Code) %>%   #set coordinate system used
sf::st_transform(4326)     #transform coordinates to WGS84 coordinates
df.sf <- sf::st_as_sf(df, coords = c(X, Y) )
my.sf.point <- sf::st_as_sf(x = df,
coords = c(lon, lat),
crs = "+proj=longlat +datum=WGS84")
lon=df$decimalLongitude
lat=df$decimalLatitude
my.sf.point <- sf::st_as_sf(x = df,
coords = c(lon, lat),
crs = "+proj=longlat +datum=WGS84")
lon
str(lon)
as.integer(lon)
as.numeric(lon)
is.numeric(lon)
my.sf.point <- sf::st_as_sf(x = df,
coords = c(lon, lat),
crs = "+proj=longlat +datum=WGS84")
st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
sf::st_as_sf(df, coords = c("lon", "lat"), crs = 4326)
lon
lat
c(lon.lat)
c(lon,lat)
df
df=as.data.frame(df)
my.sf.point <- sf::st_as_sf(x = df,
coords = c(lon, lat),
crs = "+proj=longlat +datum=WGS84")
my.sf.point <- sf::st_as_sf(x = df,
coords = c(decimalLongitude, decimalLatitude),
crs = "+proj=longlat +datum=WGS84")
my.sf.point <- sf::st_as_sf(x = df,
coords = c(df$decimalLongitude, df$decimalLatitude),
crs = "+proj=longlat +datum=WGS84")
my.sf.point <- sf::st_as_sf(x = df,
coords = c("decimalLongitude", "decimalLatitude"),
crs = "+proj=longlat +datum=WGS84")
my.sf.point
get_geographic_extent<-function(df,lon,lat, add_map="no"){
my.sf.point <- sf::st_as_sf(x = df,
coords = c(lon, lat),
crs = "+proj=longlat +datum=WGS84")
switch(add_map,
yes={map<-leaflet::leaflet() %>% addTiles() %>% addCircleMarkers( data = my.sf.point)
return(list(sf::st_bbox(my.sf.point), map))
},
no={return(sf::st_bbox(my.sf.point))
}
)
}
get_geographic_extent(df,df$decimalLongitude,df$decimalLatitude)
get_geographic_extent(df,decimalLongitude,decimalLatitude)
get_geographic_extent(df,"decimalLongitude","decimalLatitude")
get_geographic_extent(df,"decimalLongitude","decimalLatitude", add_map = "yes")
library(tidyverse)
get_geographic_extent(df,"decimalLongitude","decimalLatitude", add_map = "yes")
library(leaflet)
get_geographic_extent(df,"decimalLongitude","decimalLatitude", add_map = "yes")
get_geographic_extent(df, df$decimalLongitude,df$decimalLatitude, add_map = "yes")
get_geographic_extent(df,"decimalLongitude","decimalLatitude", add_map = "yes")
get_geographic_extent(SeaPop,"decimalLongitude","decimalLatitude", add_map = "yes")
dat<-data.frame(Tag=c(
"geographicCoverage","temporalCoverage","taxonomicCoverage","individualName",
"organizationName","positionName","deliveryPoint","city",
"postalCode","electronicMail","firstName","lastName",
"keyword" ,"keywordThesaurus","individualName","organizationName","positionName",
"deliveryPoint","city","postalCode","electronicMail",
"endDate" ,"beginDate" ,"taxonRankName","taxonRankValue",
"commonName","taxonomicClassification",
"rangeOfDates"), ParentTag=c("coverage","coverage","coverage","creator",
"creator","creator","creator","creator",
"creator", "creator","individualName",
"individualName" ,"KeywordSet","KeywordSet",
"metadataProvider","metadataProvider",
"metadataProvider","metadataProvider","metadataProvider",
"metadataProvider","metadataProvider","rangeOfDates",
"rangeOfDates","TaxonomicCoverage", "TaxonomicCoverage" ,
"TaxonomicCoverage" ,"TaxonomicCoverage" ,"TemporalCoverage"))
dat<-data.frame(Tag=c(
"geographicCoverage","temporalCoverage","taxonomicCoverage","individualName",
"organizationName","positionName","deliveryPoint","city",
"postalCode","electronicMail","firstName","lastName",
"keyword" ,"keywordThesaurus","individualName","organizationName","positionName",
"deliveryPoint","city","postalCode","electronicMail",
"endDate" ,"beginDate" ,"taxonRankName","taxonRankValue",
"commonName","taxonomicClassification",
"rangeOfDates"), ParentTag=c("coverage","coverage","coverage","creator",
"creator","creator","creator","creator",
"creator", "creator","individualName",
"individualName" ,"KeywordSet","KeywordSet",
"metadataProvider","metadataProvider",
"metadataProvider","metadataProvider","metadataProvider",
"metadataProvider","metadataProvider","rangeOfDates",
"rangeOfDates","TaxonomicCoverage", "TaxonomicCoverage" ,
"TaxonomicCoverage" ,"TaxonomicCoverage" ,"TemporalCoverage"))
library(collapsibleTree)
collapsibleTree(
dat,
hierarchy = c("ParentTag", "Tag"),
width = 800,
zoomable = FALSE
)
library(ggraph)
library(ggraph)
library(igraph)
graph=graph_from_data_frame(dat)
graph
ggraph(graph, 'dendrogram') +
geom_edge_diagonal()
ggraph(graph, 'dendrogram')
plot(graph)
graph %>%
geom_edge_link() +
geom_node_point()
graph %>%
geom_edge_link() +
geom_node_point()
graph %>%
ggraph()+
geom_edge_link() +
geom_node_point()
# Libraries
library(igraph)
library(networkD3)
# create a dataset:
data <- data_frame(
from=c("A", "A", "B", "D", "C", "D", "E", "B", "C", "D", "K", "A", "M"),
to=c("B", "E", "F", "A", "C", "A", "B", "Z", "A", "C", "A", "B", "K")
)
library(tidyverse)
# create a dataset:
data <- data_frame(
from=c("A", "A", "B", "D", "C", "D", "E", "B", "C", "D", "K", "A", "M"),
to=c("B", "E", "F", "A", "C", "A", "B", "Z", "A", "C", "A", "B", "K")
)
# Plot
p <- simpleNetwork(data, height="100px", width="100px")
p
# create a dataset:
data <- data_frame(
from=dat$ParentTag,
to=dat$Tag)
# Plot
p <- simpleNetwork(data, height="100px", width="100px")
p
library(LivingNorwayR)
devtools::document()
pkgdown::build_site()
knitr::opts_chunk$set(echo = TRUE)
library(uuid)
source(file.path(Sys.getenv("WORKSPACE_LIVINGNORWAY"), "R", "LNTagFunctions.R"))
here::here()
knitr::opts_chunk$set(echo = TRUE)
library(uuid)
library(LivingNorwayR)
#source(file.path(Sys.getenv("WORKSPACE_LIVINGNORWAY"), "R", "LNTagFunctions.R"))
LivingNorwayR::LNcreator()
library(LivingNorwayR)
pkgdown::build_site()
